# UATP RapidPay

### Overview
- **Architecture**
  - This application has been built using "clean architecture" guidelines adhering to SOLID programming principles
- **Authentication and Authorization**
  - Authentication is done using the Duende IdentityServer package.
  - The api authorizes requests by validating the JWT token generated by Identity Server
  - Any card ownership checks are done by the API by checking the subject id associated with a card with the subject id associated with a request that has a validated JWT token.
- **Storage**
  - Storage is done using EntityFramework in both the API and the IdentityServer
  - Entity Framework is configured to use SQLite
      - Entity Framework + SQLite is not thread safe, implemented ReadWrite locks.
  - Cards are cached in a ConcurrentDictionary, allowing for faster operations on the card entity.
- **Asynchronous implementation**
  - Any controller call that may operate on the database is marked as async all the way down to the database operation to improve the performance of the api application..
- **Validation**
  - FluentValidation is used for DTO validation on incoming requests
  - For validations that use multiple entities, validation functions are included in the service classes
  - Custom validation results are handled using 3 states: Success, Failure, and SecureFailure. Success will return a response DTO on the api, failure will return an error message indicating what has failed. SecureFailure will return a BadRequest without an error message(for security purposes).
- **Logging**
  - Any custom validation tasks and errors get logged, as well as anything that may have an impact on the functionality of the application as well as user data. The amount of logging is minimized while allowing for enough information to be logged for debugging purposes. Any sensitive data like card numbers is masked in a way that is usable for debugging, while making it impossible for a developer to make malicious use of these log messages.
- **Unit testing**
  - Unit tests are available. They mainly focus on the RapidPay.Core project but I have built some unit tests for the RapidPay.Infrastructre project as well.
  - Unit tests use NUnit and Moq
- **Code Quality Metrics**
  - I have used SonarQube to measure any areas of code that need improvement, and implemented fixes accordingly.

### How I would improve this application before real world deployment
- **API Layer**
  - Introduce a controller with a single "get" action that will return if the server is running and in a healthy condition, so it is easy to see if there are any problems with the service. In the case of the api being up but in an erroneous state I would only show that the server is in an unhealthy state, without divulging any internal information.
- **Infrastructure layer**
  - *Database*
      - With a credit card service, it is not unrealistic to expect millions of users attempting to use the service simultaneously. SQLite is not a high performance database service, it is not thread safe, so it requires locking. I would use a distributed azure sql database deployed in multiple regions. This makes it possible to run multiple instances of the api server in multiple regions as well so that people can always work with their credit card with low latency and high availablity.
      - Storing sensitive information like connection strings in a secret vault instead of in the project code.
  - *Caching*
      - A ConcurrentDictionary may be a great way to cache results from the SQLite database for small datasets, it will not cut it for a system where there may be millions of users with multiple credit cards each, where there will be much more information stored in the card entity as well as there being many more entities in an application. Following this approach in a real world deployment will cause the application to run out of memory quickly. I would instead use a redis cache, configuring it to intelligently keep track of what users are in what region, and what users undertake many operations to decide what cards and other entities should be cached.
- **Identity**
   - Implement SSO through multiple platforms, like Google or Microsoft.
   - Enforce 2 factor authentication
